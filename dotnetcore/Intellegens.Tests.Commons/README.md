# Intellegens.Tests.Commons
This project contains helper classes and extension with aim of removing as much as boilerplate possible and making automated tests elegant.

## WebApps
When testing .Net Core web apps/apis, parallel execution may become a problem since you'll have to start server running on port X, which can already be in use or will be in use once parallel test starts. To mitigate this, approach described below is recommended.

### Prepare test project
Create new XUnit project and add dependency to your web app. 

### Prepare test `Startup` class
In your test project, create a new `StartupTest` class and make it inherit `ITestStartup` and web app's `Startup` class. This will enable you to tweak and override startup methods and needed, and will provide you with access to test server's `HttpMessageHandler`. Since test server isn't an actual server but simulated one, all communication to it (e.g. token validation) must go to it by using `HttpClient` generated by test server, or by using `HttpMessageHandler` provided automatically to your test `Startup` class.

```csharp
public class TestSingleTenantStartup : Startup, ITestStartup
{
    public TestSingleTenantStartup(IWebHostEnvironment env) : base(env)
    {
    }

    public HttpMessageHandler BackchannelHttpHandler { get; set; }
    public IWebHostEnvironment WebHostEnvironment { get; set; }

    protected override void JwtBearerOptionsCallback(JwtBearerOptions options)
    {
        options.BackchannelHttpHandler = BackchannelHttpHandler;
        base.JwtBearerOptionsCallback(options);
    }
}
```

### Prepare `WebApplicationFactory`
`CustomWebApplicationFactoryBase<TStartup, TStartupBase>` abstract class handles creation of test server, but requires custom implementation that provides test `Startup` class instance via `ConstructStartup` method.

Also, instance of this class will be passed as a text fixture to your test class.

```csharp
public class MultitenantWebApplicationFactory : CustomWebApplicationFactoryBase<TestMultiTenantStartup, Startup>
{
    public MultitenantWebApplicationFactory() : base()
    {
    }

    protected override TestMultiTenantStartup ConstructStartup(IWebHostEnvironment webHostEnvironment)
    {
        return new TestMultiTenantStartup(webHostEnvironment);
    }
}
```

### Prepare test abstract
If you're going to run more than one test collection, it's easier to prepare a base test class. In order to do this, your abstract class must inherit `ControllerIntegrationTestBase<TStartup, TStartupBase, TFactory>` which removes a lot of the boilerplate usually needed when testing APIs.

Base constructor requires instance of `CustomWebApplicationFactoryBase` and optionally two parameters:
- `solutionRelativeDirectory`: since you use test `Startup` class now in separate project, project files and settings file are not inside. With this parameter, you set the base directory where files are located (e.g. `appsettings.json`).
- `useUserSecrets`: should user secrets specified on base project be loaded

Base class also exposes `ServiceProvider` to gain access to all resolved services, and `GetHttpClient` methods to generate `HttpClient` and other useful methods.

Since test server is constructed in constuctor of `CustomWebApplicationFactoryBase`, `OnPreInit` method can be overriden with any actions required to be taken before initialising the server.

If this abstract class will be used for single test Startup class, it doesn't need to be generic.

```csharp
public abstract class TestAbstract : ControllerIntegrationTestBase<TestMultiTenantStartup, Startup, MultitenantWebApplicationFactory>
{
    public TestAbstract(
        MultitenantWebApplicationFactory factory,
        string solutionRelativeDirectory = "IdentityUtils.Demos.IdentityServer4.MultiTenant")
        : base(factory, solutionRelativeDirectory: solutionRelativeDirectory)
    {
    }

    protected virtual string DatabaseName => "IntegrationTestDatabase.db";

    protected override void OnPreInit()
    {
        Environment.SetEnvironmentVariable("Is4Host", Factory.BaseUrl);
        Environment.SetEnvironmentVariable("DatabaseName", DatabaseName);

        DefaultClientId = "test-client-id";
        DefaultClientSecret = "511536EF-F270-4058-80CA-1C89C192F69A";
        DefaultScope = "api";

        base.OnPreInit();
    }
}
```


## Identity server
Testing apis or apps that have IdentityServer4 is specific since identity server will try to call specified host to verify access token. Since test server isn't actual server - this won't work. Somehow, `HttpMessageHandler` must be provided to it.

Steps below are recommended in these scenarios.

### Modify your original `Startup` class to allow setting up `JwtBearerOptions`
Api's `Startup` class should contain overrideable method for setting up `JwtBearerOptions` that identity utils will use when configuring token options.

```csharp
public class Startup
{
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        ...

        services
            .AddIdentityUtilsIs4MultitenancyExtensions((builder) =>
            {
                ...
                builder.AddAuthentication(Configuration["Is4Host"], Configuration["Is4AuthManagementAudience"], JwtBearerOptionsCallback)
                ...
            });
            
        ...
    }

    protected virtual void JwtBearerOptionsCallback(JwtBearerOptions options)
    {
    }
}
```

### Override `JwtBearerOptionsCallback` in test `Startup` class
Your test Startup class should provide `HttpMessageHandler` to `JwtBearerOptions` and should look similar to:
```csharp
public class TestMultiTenantStartup : Startup, ITestStartup
{
    public TestMultiTenantStartup(IWebHostEnvironment env) : base(env)
    {
    }

    public HttpMessageHandler BackchannelHttpHandler { get; set; }
    public IWebHostEnvironment WebHostEnvironment { get; set; }

    protected override void JwtBearerOptionsCallback(JwtBearerOptions options)
    {
        options.BackchannelHttpHandler = BackchannelHttpHandler;
        base.JwtBearerOptionsCallback(options);
    }
}
        
```

`IdentityServer4` will now use your test server when calling all related token endpoints.